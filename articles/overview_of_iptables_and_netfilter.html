<!DOCTYPE html>
<html>
<head>
<title>Overview Of Iptables And Netfilter</title>
<meta name="description" content="Let's take a high-level look at what iptables is and all of its various parts, so you can use it effectively.">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<h1>Overview Of Iptables And Netfilter</h1>
<p><font size="-1">Monday August 29, 2022.</font>
<br><font size="-1"><a href="../articles.html">Back To Articles</a></font>
<p>We're going to take a bird's eye view of iptables, so that we can look at all of the functionality it provides before jumping into specific exmaples of how to use it. If all you're interested in are examples, scroll to the bottom of the page.</p>
<p>You may ask - Why? The short answer: so we can understand the structure of iptables so that we can build interesting things with it.</p>
<p><b>Note:</b> Throughout this article, I will be using <code>#</code> to denote the command prompt during any terminal commands I write here, to distinguish output from commands.
<br><b>Note:</b> This article is written for Linux users. The instructions here, in particular, were tested on an Ubuntu 18.04.6 LTS release.</p>
<h2>What Is Iptables?</h2>
<p>Iptables is a linux command-line utility that is used for intercepting packets at various points in a packet's journey through the kernel, in order to determine how that packet should be processed. For that reason, iptables is typically used for firewalling - setting up your system with a bunch of rules governing which types of packets are allowed into and out of your system. In addition to packet processing, you can also use iptables to modify things like the packets' headers.</p>
<p>Iptables is built on top of <code>netfilter</code>. The Linux kernel provides a framework called <code>netfilter</code>, which allows people to write their own kernel modules and install handlers into special points in a packet's journey through the kernel - called hooks. The <code>netfilter</code> framework has 5 points you can hook into: <code>NF_IP_PRE_ROUTING</code>, <code>NF_IP_LOCAL_IN</code>, <code>NF_IP_FORWARD</code>, <code>NF_IP_LOCAL_OUT</code>, and <code>NF_IP_POST_ROUTING</code>. Iptables hooks into all 5 of these points and allows you to make decisions about (or in some cases modify) a packet when it reaches these various stages.</p>
<p>We will end up looking at all 5 of these hooks over the course of a few different articles. But for now, we will focus on the <code>NF_IP_LOCAL_IN</code> and <code>NF_IP_LOCAL_OUT</code> hooks.</p>
<h2>When The Hooks Are Triggered</h2>
<p>Each of these 5 netfilter hooks are reside at different points in a packet's journey through the system. Let's look a little closer at when each of these hooks is triggered.</p>
<ul>
<li><p><code>NF_IP_PRE_ROUTING</code>: The pre-routing hook is triggered almost as soon as a packet enters the system. This hook triggers before any routing decisions are made about the packet.</p>
<li><p><code>NF_IP_LOCAL_IN</code>: The local-in hook is triggered next by an incoming packet. This hook triggers after the routing decision has been made, but before the packet is delivered to a local process. Note that if the packet is not to be delivered locally, but is to be sent out of the system after a routing decision, then this hook will not trigger. This is only for locally-bound packets.</p>
<li><p><code>NF_IP_FORWARD</code>: The forward hook is triggered after the pre-routing hook as well for an incoming packet. Recall that the local-in hook only triggered for packets that were locally bound (destined for this machine)? Well, when that condition is not met, and the incoming packets are destined for another machine, the forward hook is triggered. It is just the other case of the local-in hook. Thus, the forward hook also triggers <i>after</i> the routing decision has been made. Note that this case of an incoming packet not destined for this machine really only happens when your machine is configured to behave as a router.</p>
<li><p><code>NF_IP_LOCAL_OUT</code>: The local-out hook is not related to the above three hooks. It is specifically for packets that originate on this machine and which are being sent out of the machine. The above three rules for were inbound traffic, and the next two are for outbound traffic. This hook triggers as soon as the outbound packet is received, before any routing decisions are made. Note that the local-out hook is only triggered for packets that were generated by this machine. Thus, if the machine is acting as a router, and routing an incoming packet, then the forward hook will be triggered but the local-out will not be, since the packet came from somewhere else. If, however, the packet originated locally, then this hook is triggered.</p>
<li><p><code>NF_IP_POST_ROUTING</code>: The post-routing hook is the second outbound traffic hook. It is triggered after routing decisions are made, and thus after the local-out hook was triggered.</p>
</ul>
<p>You'll notice, then, that the pre-routing and post-routing hooks are symmetrical. The pre-routing is the first hook, before any routing decisions, that an incoming packet encounters. Likewise, the post-routing is the last hook, after any routing decisions, that can outgoing packet encounters. There is also a symmetry in the local-in and local-out hooks. The local-in hook comes after the pre-routing hook for incoming packets, but after the routing decision has been made. And the local-out hook comes before the post-routing hook for outgoing packets, but before the routing decision has been made.</p>
<p>The forward hook is the only hook that doesn't really have a symmetrical partner. But that's because it wouldn't make sense. It only is triggered when the machine is behaving as a router and an incoming packet is destined for another machine, in which case the forward hook is triggered after the pre-routing hook (and so after a routing decision has been made). In this same instance, the post-routing hook will be triggered after the forward hook. As we can see, the forward hook sits in the middle of this, and there is no meaningful symmetrical partner it could have.</p>
<h2>Chains, Rules And Targets</h2>
<p>Iptables is all about writing rules for packet traversal through the kernel. We'll get into the details of a rule shortly, but they are essentially described by a condition and a target. The target is the action to be taken if the condition is met. So a condition may be something like "If an incoming packet is from ip address 10.0.1.2" and the target could be something like "Then destroy this packet". This is what iptables is all about, writing such rules so that you can have fine-grained control over the packets that enter and exit your system.</p>
<p>The rules are then strung together, one after another, into what iptables calls chains. Iptables provides 5 pre-defined chains for you, which you can add rules to, and also allows you to define your own chain. A chain is simply zero or more rules. The rules are ordered. When a packet comes in, each rule in the chain is evaluated against that packet in the order in which the rules are specified. If the condition is not met for a rule, then the next rule in the chain is evaluated and so on. If no conditions are met by any of the rules in a chain, then the default action of allowing the packet to continue its journey is used. If at any point a rule's condition is satisfied, then the action (as described by its target) is taken.</p>
<p>The 5 pre-defined chains iptables provide you map perfectly onto the 5 hooks netfilter provides. These chains are called: <code>PREROUTING</code>, <code>INPUT</code>, <code>FORWARD</code>, <code>OUTPUT</code>, and <code>POSTROUTING</code>. The reason they map perfectly to the 5 netfilter hooks is because each of these chains is installed in its respective netfilter hook. So, the <code>PREROUTING</code> chain is installed in the <code>NF_IP_PRE_ROUTING</code> hook. This means that when a packet passes through the "pre-routing" netfilter stage, any rules specified in the <code>PREROUTING</code> chain by iptables will be executed.</p>
<p>Just to hammer the point home, then, each of these chains are executed at the following points in a packet's journey:</p>
<ul>
<li><p>Incoming packets destined for this machine: (internet)-->[<code>PREROUTING</code>]-->(routing)-->[<code>INPUT</code>]-->(program)</p>
<li><p>Outgoing packets originating from this machine: (program)-->[<code>OUTPUT</code>]-->(routing)-->[<code>POSTROUTING</code>]-->(internet)</p>
<li><p>Incoming packets destined for another machine: (internet)-->[<code>PREROUTING</code>]--(routing)-->[<code>FORWARD</code>]-->[<code>POSTROUTING</code>]-->(internet)</p>
</ul>
<p>The (program) entry in the above descriptions refers to a locally-running program/process. For incoming packets, these packets are ultimately delivered to some running process on the machine, which then does something interesting with them, and for outgoing packets, these packets are initially generated by a locally-running process.</p>
<h2>Tables</h2>
<p>So why is it called iptables if it's all about chains of rules? Well, these chains all need somewhere to live, and as it turns out, they live in tables. Iptables consists of 5 tables, each of which has a subset of the pre-defined chains in it. We can also add our own custom chains to any of these tables as well. These tables mostly exist for organizational purposes. If we have a complex firewall and we are also doing NAT or other specialized things, if we had to write all of these rules inside our 5 chains all in the same place, things would turn into a mess in a hurry. Instead, we can compartmentalize these rules by placing them in different tables that have specific purposes. There are 5 tables, and they are called: <code>filter</code>, <code>nat</code>, <code>mangle</code>, <code>raw</code>, and <code>security</code>.</p>
<p>Let's take a look at what each of these 5 tables are supposed to be used for:</p>
<ul>
<li><p><code>filter</code>: The filter table is the default table your rules will be chained into if no table is specified. It is intended for simple firewalling, to prevent or allow specific packets from arriving or leaving the machine.</p>
<li><p><code>nat</code>: The nat table is where NAT rules should be placed, if you are trying to implement NAT. So, if you want to modify source and destination ip addresses, or things like that, this is where those rules go.</p>
<li><p><code>mangle</code>: The mangle table is where you should place rules that modify packets. Typically, iptables only allows you to modify packet headers.</p>
<li><p><code>raw</code>: The raw table is where you can place rules to mark packets so that you can ensure those packets do not get tracked. The netfilter framework is stateful, so that it can perform some useful higher-level functionality, and this statefulness is maintained by what it calls 'connection tracking'. You can use the raw table to mark a packet so that it will bypass connection tracking.</p>
<li><p><code>security</code>: The security table is where you can place rules to mark packets with security marks, such as marks for things like SELinux.</p>
</ul>
<p>I did mention that these tables exist mostly for organizational purposes, and that's true, but it's worth mentioning this organized approach is not a simple recommendation but it is also enforced in various ways. In other words, there are certain targets or things that can be done with the rules that are only allows in specific tables and not others. So, if you want to implement NAT, you'll find that most of the functionality you want is only allowed inside the nat table and you can't implement it in another table. That's worth keeping in mind.</p>
<h2>Order Of Traversal</h2>
<p>You'll notice that there are 5 chains and 5 tables. Does this mean that each table is assigned one chain only? No. If that were the case, you wouldn't be able to do the things you wanted to do very effectively. For instance, NAT can't be implemented with only a single one of the chains above. Actually, each table contains a subset of these 5 chains. Here's a list of which chains exist in which tables:</p>
<ul>
<li><p><code>filter</code>: The filter table consists of the <code>INPUT</code>, <code>OUTPUT</code>, and <code>FORWARD</code> chains.</p>
<li><p><code>nat</code>: The nat table consists of the <code>PREROUTING</code>, <code>POSTROUTING</code> <code>INPUT</code>, and <code>OUTPUT</code> chains.</p>
<li><p><code>mangle</code>: The mangle table consists of all 5 chains.</p>
<li><p><code>raw</code>: The raw table consists of the <code>PREROUTING</code> and <code>OUTPUT</code> chains.</p>
<li><p><code>security</code>: The security table consists of the same chains as the <code>filter</code> table: <code>INPUT</code>, <code>OUTPUT</code>, and <code>FORWARD</code>.</p>
</ul>
<p>However, this means that there may be rules in the <code>INPUT</code> chain of multiple tables. Which begs the question, in what order are those rules evaluated then? Well, in addition to compartmentalization, the tables also provide prioritization. Let's take a look at the priorities of these tables. A higher priority table will have its chains evaluated prior to a lower priority table. Thus, if a higher priority table takes an action like dropping a packet, then a lower priority table will never see the packet.</p>
<p>First, we need to break the <code>nat</code> table up into <code>snat</code> (source NAT) and <code>dnat</code> (destination NAT), since the nat chains have different priorities depending on which of these they are associated with. The <code>snat</code> chains are <code>INPUT</code> and <code>POSTROUTING</code> (the two chains which execute immediately before a packet is delivered, either to a local process for incoming packets or onto the internet for outgoing), and the <code>dnat</code> chains are <code>PREROUTING</code> and <code>OUTPUT</code> (the two chains which execute immediately after receiving a packet, either from the internet for incoming packets or from a process for local packets). The table priorities are thus:</p>
<ol>
<li>The <code>raw</code> table.
<li>The <code>mangle</code> table.
<li>The <code>dnat</code> portion of the <code>nat</code> table.
<li>The <code>filter</code> table.
<li>The <code>security</code> table.
<li>The <code>snat</code> portion of the <code>nat</code> table.
</ol>
<h2>Examples</h2>
<p>The purpose of this article was to provide an overview of how iptables works, so you can see all its moving parts at a high level. We're now ready to look at some specific examples of using the iptables utility to do things. That's going to be the focal point of the next few articles. Below is a list of those related articles:</p>
<ul>
<li><a href="dropping_and_rejecting_packets_with_iptables.html">Dropping And Rejecting Packets With Iptables</a>
</ul>
</body>
</html>
