<!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" href="styles.css">
<title>Building The Internet</title>
<meta name="description" content="Let's look at how we are going to encode the data we send over our ethernet cable.">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<h1>Building The Internet</h1>
<h2>Section 1: The Physical Layer</h2>
<h3>Part 2: Ethernet Framing</h3>
<p><font size="-1">Thursday December 29, 2022.</font>

<p>In the previous article, we wrote some basic code to simulate an ethernet cable. What we want to do is allow our two computers to transmit data to one another over the cable. The cable allows us to transmit binary data, one bit at a time. But we want to be able to send a message from one side to the other side, and that message is likely going to be many bits long. If we wanted to send a message like "hello world", the first question is how do we represent this message in binary?

<p>Well, all we have to do is define an encoding scheme, which allows us to translate between characters and the binary representations of those characters, and then a decoding scheme does the reverse. This way we can encode our message in binary, transmit it, and then decode it on the other side. Coming up with an encoding scheme for all of the characters is fairly easy to do. For example, we could encode 'a' as 0, 'b' as 1, 'c' as 10, 'd' as '11', and so on, giving each character a unique binary pattern. Though this pattern has some problems already. If we recevie the two bits 1 and 0, did someone send us the character 'c' or did they send us 'a' followed by 'b'? If we make all our binary patterns the same length, we can avoid this problem. For example, every character gets encoded as 4 bits, and so now 'a' is 0000, 'b' is 0001, 'c' is 0010, and 'd' is 0011, and so on.

<p>This is exactly what the ASCII encoding standard is. A popular encoding scheme for converting characters to binary and back. You can take a look at the ASCII scheme <a href="https://www.asciitable.com/">here</a> or just google "ASCII". You'll notice it encodes far more than just the latin alphabet. It also includes all sorts of symbols you can type of your computer. Typically ASCII is expressed in hexadecimal as opposed to binary, just because hexadecimal is a more terse format. Instead of writing out 8 bits for every encoding, you only need 2 hexadecimal digits to represent the same information. Of course, when it goes over the wire it is in binary. It just simply gets represented in hexadecimal for humans, since it makes it a bit easier to work with than blobs of ones and zeroes.

<p>Alright, so we've got an encoding scheme, ASCII, we're ready to send our message, right? We can convert each character in "hello world" to its binary representation and then send those bits over our cable. Actually, there's still one big problem. How does the other side know when we've started transmitting our message? Let's assume it's sitting there reading the voltage levels of its side of the wire every <code>r</code> nanoseconds. But what if it begins doing that before we've started sending our message? Then it's going to see whatever voltage happens to be on the wire at that time. It may be a one or zero, who knows. After it takes 8 readings from the cable, how will it know whether those 8 bits represent an ASCII character we intended to send it, or whether they are just whatever garbage voltage level happened to be on the wire at that time?

<p>You might think, well if it's garbage then you're going to read all zeroes in a row, or else all ones in a row, and so you can tell if its garbage or not. But not so far - eight zeros or eight ones might actually be a meaningful combination in whatever encoding we are using. Eight zeroes in ASCII is the special "null" character, which has a real meaning. Of course, we could fix this by saying eight zeros and eight ones are reserved values indicating garbage, and just adjust our encoding scheme so that it never represents any characters with those binary values. The problem is, you're assuming a garabage voltage level never fluctuates and will always remain constant over time. But it's possible the cable is damaged a bit, or there's electrical interference or something else causing a bit of flucuation. Moreover, what if the sender begins their message after you've already read 5 bits of data, now you have 5 garbage bits followed by 3 non-garbage bits in your byte - how will you know which are which? The problem gets even more hairy when we consider that we also do not know the rate at which the sender may be sending their bits of data - what if we are reading every <code>r</code> nanoseconds but the sender is sending every <code>2r</code> nanoseconds? We're going to read a totally incorrect message.

<p>To be cautious, we should assume that the writer may begin transmitting a message at any point in time, that the writer may write at an unknown speed, and that garbage data may be unpredictable.

<p>The ethernet protocol for transmitting data addresses this problem using a technique called framing. Any data which one computer wants to send to another must be encapsulated in what is called an Ethernet Frame. This is kind of like saying "I'm going to tell you something now: here it is. I just told you something" rather than just saying "here it is" out of nowhere. By surrounding the data in this "I'm going to tell you something now:" and "I just told you something." pattern, it makes it far easier to identify when data is and is not being sent. 

<p>I do want to make it clear that ethernet cables are just one type of physical media in use to transmit data between computers. There are other media besides it, like radio waves used in WiFi. But each physical medium is very particular, and I can't cover them all or even go into complete depth for one of them. The point here is to use ethernet as a good means of understanding the problems at this layer. Ethernet is still a widely used medium today, so it has relevance and is fairly simple. We're going to be discussing the ethernet protocol as defined by the IEEE 802.3 specification. There are other ethernet protocols, but as I mentioned, I cannot provide an exhaustive account here. Let's take a look at the structure of such an ethernet frame:

<p><img src="../img/ethernet_frame.png" alt="Ethernet Frame">

<p>The data being transmitted is often called a packet. The frame begins with a preamble followed by a starting delimiter. That is followed by the data, which is followed by a check sequence, and then finally the frame ends with a special delimiter. Once the frame has been transmitted, there's usually a period of time called the interpacket gap that the sender must wait before transmitting any additional data. Let's look at each of these fields individually.

<p><b>Preamble</b>: The ethernet frame preamble consists of 7 octets (an octet is 8 bits, in other words, a byte) and each of these octets has the same bit pattern, 10101010, an alternating series of ones and zeroes, beginning with one. This preamble serves two purposes, the first is that it creates a pattern that is unlikely to be accidental, and so serves as a good heuristic that a frame is being sent. The second, and more important purpose, is related to the problem mention above where the sender's transmission rate is unknown. The preamble serves as a period of time where the receiver can synchronize themselves with the sender. These ones and zeroes must be sent at the same frequency as one another, and this frequency will be used to transmit the entire frame. Writing 7 such bytes means there's going to be 56 alternating bits coming up, giving us enough time to synchronize with the sender. Once the preamble is done, the receiver now knows the rate at which to read incoming bits, taking care of that problem.

<p><b>Start Frame Delimiter</b>: This is one byte that is a special symbol indicating that the preamble is over and the actual data is about to begin. This byte has the bit pattern: 10101011. It's the same as the preamble pattern, but its final bit is one, ending the alternating pattern.

<p><b>Data Packet</b>: This is the actual data, whatever it happens to be. The ethernet protocol imposes both a minimum and a maximum size on the data. This is for a few reasons, but the most important is related to throughput. If multiple computers are sending data over the same wire, then we don't want to have an unlimited data size or someone can transmit a massive packet that blocks the entire network. Likewise, if our packet is too small the protocol becomes inefficient, because the rest of the frame is larger than the actual data. The minimum is also used to detect so-called "runt" frames, which are often the result of collisions (multiple senders trying to transmit data at the exact same time over the same medium), which becomes a problem when the physical medium is shared by multiple writers. The minimum size of the data is 64 bytes and the maximum is 1,522 bytes.

<p><b>End Frame Delimiter</b>: This is a special symbol indicating that the frame is now complete.

<p><b>Interpacket Gap</b>: This is a duration in which no other frames should be transmitted. This gives the receiver time to process the packet they just received, and get ready to receive another one. This gap period is defined as a minimum of 12 bytes in which no frame should be sent.

<p>This framing technique provides us with a means of synchronizing the two computers and formatting our data in a way that's very unlikely to be accidental. It is still possible that we could mistake garbage for a frame (if things were sufficiently broken) and it's also possible that our data could be corrupt. For instance, our two computers could get out of sync and the receiver may not receive the bits the sender transmitted. It's important to note that although this protocol allows us to transmit data packets between computers, the actual transmission is not reliable - packets may not be received and they may also be received with errors in them. That's something which we will eventually address as we work our way up the networking protocol stack, but at this layer, the physical layer, this is just the reality.

</body>
</html>
